<?php

namespace deemru;

class Shamir255
{
    // GF(256) with primitive polynomial 0x11D
    // RFC 6330, Section 5.7.3 (https://www.rfc-editor.org/rfc/rfc6330#section-5.7.3)
    // OCT_EXP[i] = 2 ^ i in GF(256), stored as integers (510 elements)
    static private $OCT_EXP =
    [
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1d, 0x3a, 0x74, 0xe8, 0xcd, 0x87, 0x13, 0x26,
        0x4c, 0x98, 0x2d, 0x5a, 0xb4, 0x75, 0xea, 0xc9, 0x8f, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0,
        0x9d, 0x27, 0x4e, 0x9c, 0x25, 0x4a, 0x94, 0x35, 0x6a, 0xd4, 0xb5, 0x77, 0xee, 0xc1, 0x9f, 0x23,
        0x46, 0x8c, 0x05, 0x0a, 0x14, 0x28, 0x50, 0xa0, 0x5d, 0xba, 0x69, 0xd2, 0xb9, 0x6f, 0xde, 0xa1,
        0x5f, 0xbe, 0x61, 0xc2, 0x99, 0x2f, 0x5e, 0xbc, 0x65, 0xca, 0x89, 0x0f, 0x1e, 0x3c, 0x78, 0xf0,
        0xfd, 0xe7, 0xd3, 0xbb, 0x6b, 0xd6, 0xb1, 0x7f, 0xfe, 0xe1, 0xdf, 0xa3, 0x5b, 0xb6, 0x71, 0xe2,
        0xd9, 0xaf, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88, 0x0d, 0x1a, 0x34, 0x68, 0xd0, 0xbd, 0x67, 0xce,
        0x81, 0x1f, 0x3e, 0x7c, 0xf8, 0xed, 0xc7, 0x93, 0x3b, 0x76, 0xec, 0xc5, 0x97, 0x33, 0x66, 0xcc,
        0x85, 0x17, 0x2e, 0x5c, 0xb8, 0x6d, 0xda, 0xa9, 0x4f, 0x9e, 0x21, 0x42, 0x84, 0x15, 0x2a, 0x54,
        0xa8, 0x4d, 0x9a, 0x29, 0x52, 0xa4, 0x55, 0xaa, 0x49, 0x92, 0x39, 0x72, 0xe4, 0xd5, 0xb7, 0x73,
        0xe6, 0xd1, 0xbf, 0x63, 0xc6, 0x91, 0x3f, 0x7e, 0xfc, 0xe5, 0xd7, 0xb3, 0x7b, 0xf6, 0xf1, 0xff,
        0xe3, 0xdb, 0xab, 0x4b, 0x96, 0x31, 0x62, 0xc4, 0x95, 0x37, 0x6e, 0xdc, 0xa5, 0x57, 0xae, 0x41,
        0x82, 0x19, 0x32, 0x64, 0xc8, 0x8d, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xdd, 0xa7, 0x53, 0xa6,
        0x51, 0xa2, 0x59, 0xb2, 0x79, 0xf2, 0xf9, 0xef, 0xc3, 0x9b, 0x2b, 0x56, 0xac, 0x45, 0x8a, 0x09,
        0x12, 0x24, 0x48, 0x90, 0x3d, 0x7a, 0xf4, 0xf5, 0xf7, 0xf3, 0xfb, 0xeb, 0xcb, 0x8b, 0x0b, 0x16,
        0x2c, 0x58, 0xb0, 0x7d, 0xfa, 0xe9, 0xcf, 0x83, 0x1b, 0x36, 0x6c, 0xd8, 0xad, 0x47, 0x8e,
        // Repeat first 255 elements to avoid mod 255 in multiplication
        0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1d, 0x3a, 0x74, 0xe8, 0xcd, 0x87, 0x13, 0x26,
        0x4c, 0x98, 0x2d, 0x5a, 0xb4, 0x75, 0xea, 0xc9, 0x8f, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0,
        0x9d, 0x27, 0x4e, 0x9c, 0x25, 0x4a, 0x94, 0x35, 0x6a, 0xd4, 0xb5, 0x77, 0xee, 0xc1, 0x9f, 0x23,
        0x46, 0x8c, 0x05, 0x0a, 0x14, 0x28, 0x50, 0xa0, 0x5d, 0xba, 0x69, 0xd2, 0xb9, 0x6f, 0xde, 0xa1,
        0x5f, 0xbe, 0x61, 0xc2, 0x99, 0x2f, 0x5e, 0xbc, 0x65, 0xca, 0x89, 0x0f, 0x1e, 0x3c, 0x78, 0xf0,
        0xfd, 0xe7, 0xd3, 0xbb, 0x6b, 0xd6, 0xb1, 0x7f, 0xfe, 0xe1, 0xdf, 0xa3, 0x5b, 0xb6, 0x71, 0xe2,
        0xd9, 0xaf, 0x43, 0x86, 0x11, 0x22, 0x44, 0x88, 0x0d, 0x1a, 0x34, 0x68, 0xd0, 0xbd, 0x67, 0xce,
        0x81, 0x1f, 0x3e, 0x7c, 0xf8, 0xed, 0xc7, 0x93, 0x3b, 0x76, 0xec, 0xc5, 0x97, 0x33, 0x66, 0xcc,
        0x85, 0x17, 0x2e, 0x5c, 0xb8, 0x6d, 0xda, 0xa9, 0x4f, 0x9e, 0x21, 0x42, 0x84, 0x15, 0x2a, 0x54,
        0xa8, 0x4d, 0x9a, 0x29, 0x52, 0xa4, 0x55, 0xaa, 0x49, 0x92, 0x39, 0x72, 0xe4, 0xd5, 0xb7, 0x73,
        0xe6, 0xd1, 0xbf, 0x63, 0xc6, 0x91, 0x3f, 0x7e, 0xfc, 0xe5, 0xd7, 0xb3, 0x7b, 0xf6, 0xf1, 0xff,
        0xe3, 0xdb, 0xab, 0x4b, 0x96, 0x31, 0x62, 0xc4, 0x95, 0x37, 0x6e, 0xdc, 0xa5, 0x57, 0xae, 0x41,
        0x82, 0x19, 0x32, 0x64, 0xc8, 0x8d, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xdd, 0xa7, 0x53, 0xa6,
        0x51, 0xa2, 0x59, 0xb2, 0x79, 0xf2, 0xf9, 0xef, 0xc3, 0x9b, 0x2b, 0x56, 0xac, 0x45, 0x8a, 0x09,
        0x12, 0x24, 0x48, 0x90, 0x3d, 0x7a, 0xf4, 0xf5, 0xf7, 0xf3, 0xfb, 0xeb, 0xcb, 0x8b, 0x0b, 0x16,
        0x2c, 0x58, 0xb0, 0x7d, 0xfa, 0xe9, 0xcf, 0x83, 0x1b, 0x36, 0x6c, 0xd8, 0xad, 0x47, 0x8e
    ];

    // RFC 6330, Section 5.7.2 (https://www.rfc-editor.org/rfc/rfc6330#section-5.7.2)
    // OCT_LOG[x] = i such that OCT_EXP[i] = x, stored as integers (256 elements)
    static private $OCT_LOG =
    [
        0x00, 0x00, 0x01, 0x19, 0x02, 0x32, 0x1a, 0xc6, 0x03, 0xdf, 0x33, 0xee, 0x1b, 0x68, 0xc7, 0x4b,
        0x04, 0x64, 0xe0, 0x0e, 0x34, 0x8d, 0xef, 0x81, 0x1c, 0xc1, 0x69, 0xf8, 0xc8, 0x08, 0x4c, 0x71,
        0x05, 0x8a, 0x65, 0x2f, 0xe1, 0x24, 0x0f, 0x21, 0x35, 0x93, 0x8e, 0xda, 0xf0, 0x12, 0x82, 0x45,
        0x1d, 0xb5, 0xc2, 0x7d, 0x6a, 0x27, 0xf9, 0xb9, 0xc9, 0x9a, 0x09, 0x78, 0x4d, 0xe4, 0x72, 0xa6,
        0x06, 0xbf, 0x8b, 0x62, 0x66, 0xdd, 0x30, 0xfd, 0xe2, 0x98, 0x25, 0xb3, 0x10, 0x91, 0x22, 0x88,
        0x36, 0xd0, 0x94, 0xce, 0x8f, 0x96, 0xdb, 0xbd, 0xf1, 0xd2, 0x13, 0x5c, 0x83, 0x38, 0x46, 0x40,
        0x1e, 0x42, 0xb6, 0xa3, 0xc3, 0x48, 0x7e, 0x6e, 0x6b, 0x3a, 0x28, 0x54, 0xfa, 0x85, 0xba, 0x3d,
        0xca, 0x5e, 0x9b, 0x9f, 0x0a, 0x15, 0x79, 0x2b, 0x4e, 0xd4, 0xe5, 0xac, 0x73, 0xf3, 0xa7, 0x57,
        0x07, 0x70, 0xc0, 0xf7, 0x8c, 0x80, 0x63, 0x0d, 0x67, 0x4a, 0xde, 0xed, 0x31, 0xc5, 0xfe, 0x18,
        0xe3, 0xa5, 0x99, 0x77, 0x26, 0xb8, 0xb4, 0x7c, 0x11, 0x44, 0x92, 0xd9, 0x23, 0x20, 0x89, 0x2e,
        0x37, 0x3f, 0xd1, 0x5b, 0x95, 0xbc, 0xcf, 0xcd, 0x90, 0x87, 0x97, 0xb2, 0xdc, 0xfc, 0xbe, 0x61,
        0xf2, 0x56, 0xd3, 0xab, 0x14, 0x2a, 0x5d, 0x9e, 0x84, 0x3c, 0x39, 0x53, 0x47, 0x6d, 0x41, 0xa2,
        0x1f, 0x2d, 0x43, 0xd8, 0xb7, 0x7b, 0xa4, 0x76, 0xc4, 0x17, 0x49, 0xec, 0x7f, 0x0c, 0x6f, 0xf6,
        0x6c, 0xa1, 0x3b, 0x52, 0x29, 0x9d, 0x55, 0xaa, 0xfb, 0x60, 0x86, 0xb1, 0xbb, 0xcc, 0x3e, 0x5a,
        0xcb, 0x59, 0x5f, 0xb0, 0x9c, 0xa9, 0xa0, 0x51, 0x0b, 0xf5, 0x16, 0xeb, 0x7a, 0x75, 0x2c, 0xd7,
        0x4f, 0xae, 0xd5, 0xe9, 0xe6, 0xe7, 0xad, 0xe8, 0x74, 0xd6, 0xf4, 0xea, 0xa8, 0x50, 0x58, 0xaf
    ];

    /**
     * Multiply two elements in GF(256)
     */
    static private function gf_mul( $a, $b )
    {
        if( $a === 0 || $b === 0 )
            return 0;
        return self::$OCT_EXP[self::$OCT_LOG[$a] + self::$OCT_LOG[$b]];
    }

    /**
     * Divide two elements in GF(256)
     * Returns false if $b === 0 (should not happen with valid unique x)
     */
    static private function gf_div( $a, $b )
    {
        if( $b === 0 )
            return false;
        if( $a === 0 )
            return 0;
        return self::$OCT_EXP[self::$OCT_LOG[$a] - self::$OCT_LOG[$b] + 255];
    }

    /**
     * Get cryptographically secure random bytes
     * @return string|false Random bytes or false if no CSPRNG available
     */
    static private function random( $length )
    {
        if( function_exists( 'random_bytes' ) )
        {
            try
            {
                return random_bytes( $length );
            }
            catch( \Exception $e )
            {
                return false;
            }
        }

        if( function_exists( 'openssl_random_pseudo_bytes' ) )
        {
            $strong = false;
            $random = openssl_random_pseudo_bytes( $length, $strong );
            if( $random !== false && $strong === true )
                return $random;
        }

        if( function_exists( 'mcrypt_create_iv' ) )
        {
            $random = mcrypt_create_iv( $length, MCRYPT_DEV_URANDOM );
            if( $random !== false )
                return $random;
        }

        return false;
    }

    /**
     * Splits a secret into multiple shares.
     *
     * @param string $secret Secret to be shared.
     * @param int    $needed Minimum number of shares required to recover the secret (2..total).
     * @param int    $total  Total number of shares to generate (needed..255).
     *
     * @return array|false Array of shares [ x => y_bytes ] on success, or false on failure.
     */
    static public function share( $secret, $needed, $total )
    {
        $len = strlen( $secret );

        if( $len === 0 )
            return false;

        if( $needed < 2 )
            return false;

        if( $needed > $total )
            return false;

        if( $total > 255 )
            return false;

        // Generate random coefficients for each byte position
        // For each byte j: f_j( x ) = secret[j] + a1[j] * x + a2[j] * x ^ 2 + ... + a_{needed - 1}[j] * x ^ {needed - 1}
        $rndLen = $len * ( $needed - 1 );
        $rnd = self::random( $rndLen );
        if( $rnd === false )
            return false;

        // Build shares using inline Horner's method
        $shares = [];
        for( $x = 1; $x <= $total; ++$x )
        {
            $xLog = self::$OCT_LOG[$x];
            $y = '';
            for( $j = 0; $j < $len; ++$j )
            {
                // Horner: start from highest coefficient a_{needed - 1}
                // res = a_{needed - 1}
                // for k = needed - 2 down to 1: res = a_k XOR gf_mul( res, x )
                // res = secret[j] XOR gf_mul( res, x )
                $base = $j * ( $needed - 1 );
                $res = ord( $rnd[$base + $needed - 2] ); // a_{needed-1}

                for( $k = $needed - 3; $k >= 0; --$k )
                {
                    // res = a_{k + 1} XOR gf_mul( res, x )
                    if( $res !== 0 )
                        $res = self::$OCT_EXP[self::$OCT_LOG[$res] + $xLog];
                    $res ^= ord( $rnd[$base + $k] );
                }

                // Final: res = secret[j] XOR gf_mul( res, x )
                if( $res !== 0 )
                    $res = self::$OCT_EXP[self::$OCT_LOG[$res] + $xLog];
                $res ^= ord( $secret[$j] );

                $y .= chr( $res );
            }
            $shares[$x] = $y;
        }

        return $shares;
    }

    /**
     * Recovers the original secret from a set of shares.
     *
     * @param array $shares Array of shares with X => Y.
     *
     * @return string|false Recovered secret on success, or false on failure.
     */
    static public function recover( $shares )
    {
        $count = count( $shares );
        if( $count < 2 )
            return false;

        $xs = [];
        $ys = [];
        $len = null;

        foreach( $shares as $x => $y )
        {
            $xi = (int)$x;

            if( $xi < 1 || $xi > 255 )
                return false;

            if( isset( $xs[$xi] ) )
                return false;

            if( !is_string( $y ) )
                return false;

            $ylen = strlen( $y );
            if( $len === null )
            {
                if( $ylen === 0 )
                    return false;
                $len = $ylen;
            }
            else
            if( $ylen !== $len )
                return false;

            $xs[$xi] = $xi;
            $ys[$xi] = $y;
        }

        // Convert to indexed arrays for easier iteration
        $xList = array_values( $xs );
        $yList = array_values( $ys );

        // Precompute Lagrange coefficients for interpolation at x = 0
        // L_i = prod( j != i ) x_j / ( x_j - x_i ) in GF(256)
        $lambdas = [];
        for( $i = 0; $i < $count; ++$i )
        {
            $xi = $xList[$i];
            $num = 1;
            $den = 1;
            for( $j = 0; $j < $count; ++$j )
            {
                if( $i === $j )
                    continue;
                $xj = $xList[$j];
                $num = self::gf_mul( $num, $xj );
                $den = self::gf_mul( $den, $xj ^ $xi ); // x_j - x_i = x_j XOR x_i in GF(256)
            }
            $lambda = self::gf_div( $num, $den );
            if( $lambda === false )
                return false;
            $lambdas[$i] = $lambda;
        }

        // Interpolate each byte position
        $secret = '';
        for( $j = 0; $j < $len; ++$j )
        {
            $sj = 0;
            for( $i = 0; $i < $count; ++$i )
                $sj ^= self::gf_mul( ord( $yList[$i][$j] ), $lambdas[$i] );
            $secret .= chr( $sj );
        }

        return $secret;
    }
}
